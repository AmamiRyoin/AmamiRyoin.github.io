<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmamiRyoin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/519c77666d4e273ee974364c067bbaa1</icon>
  <subtitle>守得云开见月明</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T13:03:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AmamiRyoin</name>
    <email>1164101687@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React杂谈之Immutable</title>
    <link href="http://yoursite.com/2018/03/27/React%E6%9D%82%E8%B0%88%E4%B9%8BImmutable/"/>
    <id>http://yoursite.com/2018/03/27/React杂谈之Immutable/</id>
    <published>2018-03-27T06:23:07.000Z</published>
    <updated>2018-03-29T13:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React杂谈之Immutable-js"><a href="#React杂谈之Immutable-js" class="headerlink" title="React杂谈之Immutable.js"></a>React杂谈之Immutable.js</h1><h2 id="Immutable-js是什么，有何意义"><a href="#Immutable-js是什么，有何意义" class="headerlink" title="Immutable.js是什么，有何意义"></a>Immutable.js是什么，有何意义</h2><p><code>immutable</code>从英文翻译过来叫做<code>不可改变的</code>，所以<code>Immutable.js</code>就是用来生成不可变的数据的。</p><h3 id="Javascript的缺陷"><a href="#Javascript的缺陷" class="headerlink" title="Javascript的缺陷"></a>Javascript的缺陷</h3><p>众所周知在javascript中，对象一般是可变的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo=&#123;a: 1&#125;; </span><br><span class="line">let bar=foo; </span><br><span class="line">bar.a=2;</span><br><span class="line">console.log(foo.a)  // 2</span><br></pre></td></tr></table></figure></p><p>这里可以看出foo的a属性其实也跟着bar中的a属性发生了改变。</p><h3 id="Immutable的定义"><a href="#Immutable的定义" class="headerlink" title="Immutable的定义"></a>Immutable的定义</h3><p>这里就直接引用官方的原话了：</p><p>Immutable 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>那如果通过immutable来对对象进行操作会怎样呢，下面来看代码以便于更好地理解上面一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Immutable from &apos;immutable&apos;;</span><br><span class="line">let foo = Immutable.Object(&#123;a:1&#125;);</span><br><span class="line">let bar = foo.set(&apos;a&apos;,2);   // 定义一个bar变量，并且将一个新的Immutable返回给它</span><br><span class="line">console.log(foo.get(&apos;a&apos;));    // 获取foo对象(Immutable)的a属性，结果是1</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出虽然赋值给bar的时候对foo进行了修改操作，但是foo中的属性值并没有发生变化，这也就印证了上述所说‘Immutable 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象’的这句话。</p><h3 id="Immutable的意义"><a href="#Immutable的意义" class="headerlink" title="Immutable的意义"></a>Immutable的意义</h3><p>那么说了这么多，这个Immutable的意义究竟在哪里。这里主要分为以下几点：</p><ul><li><p>Immutable 降低了 Mutable 带来的复杂度</p><p>  可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function touchAndLog(touchFn) &#123;</span><br><span class="line">    let data = &#123; key: &apos;value&apos; &#125;;</span><br><span class="line">    touchFn(data);</span><br><span class="line">    console.log(data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在上述代码中你不可能知道到底会打印出什么，因为我们无法确定touchFn对data到底做了哪些操作。那如果这个data是个Immutable类型的数据呢，毫无疑问打印出来是<code>value</code>。</p></li><li><p>节省内存</p><p>  Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</p></li><li><p>可以做到对于数据应用的时间旅行等功能</p><p>  因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</p></li><li><p>函数式编程</p><p>  Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</p></li></ul><h2 id="与React全家桶摩擦出的火花"><a href="#与React全家桶摩擦出的火花" class="headerlink" title="与React全家桶摩擦出的火花"></a>与React全家桶摩擦出的火花</h2><h3 id="在React中使用Immutable的好处"><a href="#在React中使用Immutable的好处" class="headerlink" title="在React中使用Immutable的好处"></a>在React中使用Immutable的好处</h3><p>其实下面这张图更方便理解：</p><p><img src="/images/immutable1.gif" alt="Immutable"></p><p>当数据发生改变的时候，只有关联节点会被修改，其他节点则会被复制一份，最终产生一个新的数据树；</p><p>由于react中我们只要执行了this.setState()方法，不管state的值是否发生变化都会重新执行一遍render方法进行重新渲染，所以在react中有一个名为<code>shouldComponentUpdate</code>的钩子函数，它会根据你返回的布尔值来进行判断是否重新进行渲染，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class CounterButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;count: 1&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    if (this.props.color !== nextProps.color) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.state.count !== nextState.count) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        color=&#123;this.props.color&#125;</span><br><span class="line">        onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</span><br><span class="line">        Count: &#123;this.state.count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是官方给的例子，然而可以看出来如果state结构异常复杂的话(<code>比如对象的嵌套</code>)这种比较是没有用的，这里存在着浅比较的问题这个钩子函数也会相应的变得复杂。(这里不明白的话可以去看<code>shouldComponentUpdate</code>的源码，对于嵌套对象的比较是用的<code>Object.is()</code>方法进行的比较)</p><p>对于这种情况，immutable就是一个非常好的解决方案，由于immutable的不可变性，我们可以非常轻松的在<code>shouldComponentUpdate</code>中进行<code>prevProps</code>和<code>nextProps</code>的比较。</p><p>Immutable中提供is()方法来进行Immutable对象间的比较,它比较的是两个对象的 hashCode 或 valueOf，由于<code>Immutable</code>内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p><h3 id="Immutable与Redux摩擦出的火花"><a href="#Immutable与Redux摩擦出的火花" class="headerlink" title="Immutable与Redux摩擦出的火花"></a>Immutable与Redux摩擦出的火花</h3><p>综上所述，为了避免浅比较存在的问题并且能够在redux数据流中进行react的渲染优化，我们可以将Immutable引入进来，引入Immutable就意味着要修改原本的数据结构类型，这就意味着我们要修改Action和Reducer以及组件中所有用到state的地方（工作量稍微有点庞大）,对于<code>Reducer</code>的修改    这里可以引入<code>redux-immutable</code>这个库。</p><p>修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; combineReducers &#125; from &apos;redux-immutablejs&apos;;</span><br><span class="line"></span><br><span class="line">import Immutable from &apos;immutable&apos;;</span><br><span class="line">import * as reducers from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">const reducer = combineReducers(reducers);</span><br><span class="line">const state = Immutable.fromJS(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">const store = reducer(state);</span><br><span class="line">export default createStore(reducer, store);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//reducers.js</span><br><span class="line"></span><br><span class="line">import &#123; createReducer &#125; from &apos;redux-immutablejs&apos;</span><br><span class="line">const initialState = Immutable.fromJS(&#123; isAuth: false &#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reducer domain that handles authentication &amp; authorization.</span><br><span class="line"> **/</span><br><span class="line">export default createReducer(initialState, &#123;</span><br><span class="line">  [LOGIN]: (state, action) =&gt; state.merge(&#123;</span><br><span class="line">    isAuth: true,</span><br><span class="line">    token: action.payload.token</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//container.js</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">    todos: state.get(&apos;todos&apos;).get(&apos;items&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">    actions: bindActionCreators(TodoActions, dispatch)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(App)</span><br></pre></td></tr></table></figure><p>对于container你也可以直接映射一个Immutable对象给state，通过get方法传递到元素中去，这里随便个人的喜好了。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>edit by AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React杂谈之Immutable-js&quot;&gt;&lt;a href=&quot;#React杂谈之Immutable-js&quot; class=&quot;headerlink&quot; title=&quot;React杂谈之Immutable.js&quot;&gt;&lt;/a&gt;React杂谈之Immutable.js&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>HTML与Css小技巧(1)</title>
    <link href="http://yoursite.com/2018/03/24/HTML%E4%B8%8ECss%E5%B0%8F%E6%8A%80%E5%B7%A7(1)/"/>
    <id>http://yoursite.com/2018/03/24/HTML与Css小技巧(1)/</id>
    <published>2018-03-24T14:00:30.000Z</published>
    <updated>2018-03-24T14:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML与Css小技巧-1"><a href="#HTML与Css小技巧-1" class="headerlink" title="HTML与Css小技巧(1)"></a>HTML与Css小技巧(1)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗话说能用css解决的问题千万别用js，这里主要就给各位大佬介绍下不常用的或者说是新奇的css小技巧。</p><h3 id="css-混合模式"><a href="#css-混合模式" class="headerlink" title="css 混合模式"></a>css 混合模式</h3><p>熟悉PS的人应该都知道混合模式，实际上在<code>canvas</code>和<code>svg</code>中也有涉及，而在<code>css</code>中混合模式被称为<code>mix-blend-mode</code>，属性如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mix-blend-mode： normal;          //正常</span><br><span class="line">mix-blend-mode： multiply;        //正片叠底</span><br><span class="line">mix-blend-mode： screen;          //滤色</span><br><span class="line">mix-blend-mode： overlay;         //叠加</span><br><span class="line">mix-blend-mode： darken;          //变暗</span><br><span class="line">mix-blend-mode： lighten;         //变亮</span><br><span class="line">mix-blend-mode： color-dodge;     //颜色减淡</span><br><span class="line">mix-blend-mode： color-burn;      //颜色加深</span><br><span class="line">mix-blend-mode： hard-light;      //强光</span><br><span class="line">mix-blend-mode： soft-light;      //柔光</span><br><span class="line">mix-blend-mode： difference;      //差值</span><br><span class="line">mix-blend-mode： exclusion;       //排除</span><br><span class="line">mix-blend-mode： hue;             //色相</span><br><span class="line">mix-blend-mode： saturation;      //饱和度</span><br><span class="line">mix-blend-mode： color;           //颜色</span><br><span class="line">mix-blend-mode： luminosity;      //亮度</span><br><span class="line"></span><br><span class="line">mix-blend-mode： initial;         //初始</span><br><span class="line">mix-blend-mode： inherit;         //继承</span><br><span class="line">mix-blend-mode： unset;           //复原</span><br></pre></td></tr></table></figure><p>额，具体的什么效果我就不说了，程序员当然都是直接上代码啊！</p><p><div class="blend"><h4>请选择以下选项改变mix-blend-mode属性<br>    <select><br>        <option value="normal" selected>normal-正常</option><br>        <option value="multiply">multiply-正片叠底</option><br>        <option value="screen">screen-滤色</option><br>        <option value="overlay">overlay-叠加</option><br>        <option value="darken">darken-变暗</option><br>        <option value="lighten">lighten-变亮</option><br>        <option value="color-dodge">color-dodge-颜色减淡</option><br>        <option value="color-burn">color-burn-颜色加深</option><br>        <option value="hard-light">hard-light-强光</option><br>        <option value="soft-light">soft-light-柔光</option><br>        <option value="difference">difference-差值(</option><br>        <option value="exclusion">exclusion-排除</option><br>        <option value="hue">hue-色相</option><br>        <option value="saturation">saturation-饱和度</option><br>        <option value="color">color-颜色</option><br>        <option value="luminosity">luminosity-亮度</option><br>        <option value="initial">initial-初始</option><br>        <option value="inherit">inherit-继承</option><br>        <option value="unset">unset-复原</option><br>    </select><br></h4></div></p><p><style>.blend {width:100%;height:717px;background: url(/images/haruka_mana.jpg) no-repeat left top, url(/images/765pro.jpg) no-repeat left bottom;}</style></p><script type="text/javascript">if (window.addEventListener) {var eleBox = document.getElementsByClassName("blend")[0], eleSelect;if (eleBox && (eleSelect = eleBox.querySelector("select"))) {eleSelect.addEventListener("change", function() {eleBox.style.backgroundBlendMode = this.value;});}}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML与Css小技巧-1&quot;&gt;&lt;a href=&quot;#HTML与Css小技巧-1&quot; class=&quot;headerlink&quot; title=&quot;HTML与Css小技巧(1)&quot;&gt;&lt;/a&gt;HTML与Css小技巧(1)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
    
      <category term="HTML与CSS" scheme="http://yoursite.com/tags/HTML%E4%B8%8ECSS/"/>
    
  </entry>
  
  <entry>
    <title>日常Js学习汇总(1)</title>
    <link href="http://yoursite.com/2018/03/24/%E6%97%A5%E5%B8%B8Js%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB(1)/"/>
    <id>http://yoursite.com/2018/03/24/日常Js学习汇总(1)/</id>
    <published>2018-03-24T08:07:25.000Z</published>
    <updated>2018-03-24T12:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常Js学习汇总-1"><a href="#日常Js学习汇总-1" class="headerlink" title="日常Js学习汇总(1)"></a>日常Js学习汇总(1)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年11月份本来就打算开始写博客的结果拖到现在，也是服了自己的执行力了，不过总算也是开始写起来了。如果觉得写的不错，各位看官还请打个赏呗#滑稽<br>上个月刚跳槽换公司，面试时候出的笔试题当初做的一脸懵逼啊，倒不是说难，反而可以说是太基础，基础到平时大家都不会怎么去用（只是以我个人的观点来看，我承认自己基本功不是很扎实#流下了弱者的泪水），这里就凭着本人不算强的记忆力，把这些题目分享下。</p><h3 id="Js基础之Number对象"><a href="#Js基础之Number对象" class="headerlink" title="Js基础之Number对象"></a>Js基础之Number对象</h3><p>Number 对象是原始数值的包装对象。</p><h4 id="创建-Number-对象的语法："><a href="#创建-Number-对象的语法：" class="headerlink" title="创建 Number 对象的语法："></a>创建 Number 对象的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myNum=new Number(value);</span><br><span class="line">var myNum=Number(value);</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>参数 <code>value</code> 是要创建的 Number 对象的数值，或是要转换成数字的值。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，并且返回这个值（如果转换失败，则返回 NaN）。</p><h3 id="Number-对象属性"><a href="#Number-对象属性" class="headerlink" title="Number 对象属性"></a>Number 对象属性</h3><ul><li><p><code>constructor</code> ——–返回对此对象的 Number 函数的引用。</p></li><li><p><code>MAX_VALUE</code> ——–表示的最大的数。</p></li><li><p><code>Min_VALUE</code> ——–表示的最小的数。</p></li><li><p><code>NaN</code> ——–非数字值。(可以理解为Not a Number)</p></li><li><p><code>NEGATIVE_INFINITY</code> ——–负无穷大，溢出时返回该值。</p></li><li><p><code>POSITIVE_INFINITY</code> ——–正无穷大，溢出时返回该值。</p></li><li><p><code>prototype</code> ———原型。</p></li></ul><h3 id="Number-对象方法"><a href="#Number-对象方法" class="headerlink" title="Number 对象方法"></a>Number 对象方法</h3><ul><li><p><code>toString</code> ———把数字转换为字符串，使用指定的基数。</p></li><li><p><code>toLocaleString</code> ——–把数字转换为字符串，使用本地数字格式顺序。</p></li><li><p><code>toFixed</code> ——–把数字转换为字符串，结果的小数点后有指定位数的数字。</p></li><li><p><code>toExponential</code> ——–把对象的值转换为指数计数法。(这个不查手册还真不知道还有这种方法)</p></li><li><p><code>toPrecision</code> ——–把数字格式化为指定的长度。（这个也是查了手册才知道的）</p></li><li><p><code>valueOf</code> ——–返回一个 Number 对象的基本数字值。</p></li></ul><h3 id="对于Number对象的描述"><a href="#对于Number对象的描述" class="headerlink" title="对于Number对象的描述"></a>对于Number对象的描述</h3><p>在 <code>JavaScript</code> 中，数字是一种基本的数据类型。<code>JavaScript</code> 支持 <code>Number</code> 对象，该对象是原始数值的包装对象。在必要时，<code>JavaScript</code> 会自动地在原始数据和对象之间转换。构造函数 <code>Number()</code> 可以不与运算符 <code>new</code> 一起使用，而直接作为转化函数来使用。以这种方式调用 <code>Number()</code> 时，它会把自己的参数转化成一个数字，然后返回转换后的原始数值（或 <code>NaN</code>）。构造函数通常还用作 5 个有用的数字常量的占位符，这 5 个有用的数字常量分别是可表示的最大数、可表示的最小数、正无穷大、负无穷大和特殊的 <code>NaN</code> 值。 注意，这些值是构造函数 <code>Number()</code> 自身的属性，而不是单独的某个 <code>Number</code> 对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var big = Number.MAX_VALUE //正解</span><br><span class="line"></span><br><span class="line">var n= new Number(2);</span><br><span class="line">var big = n.MAX_VALUE; //错误用法，这里的变量n是new了Number对象，所以这里的n是Number的一个构造函数，并不是Number对象，所以它没有MAX_VALUE这个属性</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日常Js学习汇总-1&quot;&gt;&lt;a href=&quot;#日常Js学习汇总-1&quot; class=&quot;headerlink&quot; title=&quot;日常Js学习汇总(1)&quot;&gt;&lt;/a&gt;日常Js学习汇总(1)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
