<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AmamiRyoin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/519c77666d4e273ee974364c067bbaa1</icon>
  <subtitle>守得云开见月明</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-27T07:37:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AmamiRyoin</name>
    <email>1164101687@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js实现图片转成ASCII码</title>
    <link href="http://yoursite.com/2018/06/27/js%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E6%88%90ASCII%E7%A0%81/"/>
    <id>http://yoursite.com/2018/06/27/js实现图片转成ASCII码/</id>
    <published>2018-06-27T07:24:18.000Z</published>
    <updated>2018-06-27T07:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js实现图片转成ASCII码"><a href="#js实现图片转成ASCII码" class="headerlink" title="js实现图片转成ASCII码"></a>js实现图片转成ASCII码</h1><p>之前有朋友问我微信头像（ASCII码构成的头像）怎么搞的，感觉很有意思，所以趁着项目转测没啥bug把这个写了。</p><h2 id="canvas实现"><a href="#canvas实现" class="headerlink" title="canvas实现"></a>canvas实现</h2><p>直接上代码了，不啰嗦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot;/&gt;</span><br><span class="line">        &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">        &lt;div id=&quot;img&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            $(&quot;input&quot;).on(&apos;input&apos;,function()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                var file = $(&quot;input&quot;)[0].files[0];</span><br><span class="line">                var reader = new FileReader();</span><br><span class="line">                reader.onload=function()&#123;</span><br><span class="line">                    var canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">                    var context = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">                    var img = new Image();</span><br><span class="line">                    img.src = this.result;</span><br><span class="line">                    img.onload =function()&#123;</span><br><span class="line">                        this.width = this.width*0.2;</span><br><span class="line">                        this.height = this.height*0.2;//图片像素太大所以将图片品质压缩下</span><br><span class="line">                        invert(this,this.width,this.height);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    function invert(img,w,h) &#123;</span><br><span class="line">                        canvas.width = w;</span><br><span class="line">                        canvas.height = h;</span><br><span class="line">                        context.drawImage(img,0,0,w,h);</span><br><span class="line">                        //获取图片对象以及元素点的数组</span><br><span class="line">                        var img1 = context.getImageData(0, 0, w, h);</span><br><span class="line">                        var data = img1.data;</span><br><span class="line">                        //转换灰度图</span><br><span class="line">                        var arr=[&quot;M&quot;,&quot;N&quot;,&quot;H&quot;,&quot;Q&quot;,&quot;$&quot;,&quot;O&quot;,&quot;C&quot;,&quot;?&quot;,&quot;7&quot;,&quot;&gt;&quot;,&quot;!&quot;,&quot;:&quot;,&quot;–&quot;,&quot;;&quot;,&quot;.&quot;];</span><br><span class="line">                        var result=[];</span><br><span class="line">                        for (var i = 0, len = data.length; i &lt; len; i += 4) &#123; //一个像素点对应数组种四个元素</span><br><span class="line">                            var avg=(data[i]+data[i+1]+data[i+2])/3;</span><br><span class="line">                            var num=Math.floor(avg/18); //arr长度为14，要让num落在0-14中，而rgb为0-255，因此除18</span><br><span class="line">                            result.push(arr[num]);</span><br><span class="line">                            if((i+4)%(w*4)==0&amp;&amp;i!=0)&#123;   //ASCII码换行</span><br><span class="line">                                result.push(&quot;&lt;br/&gt;&quot;)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        document.getElementById(&quot;img&quot;).innerHTML=result.join();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                reader.readAsDataURL(file)</span><br><span class="line">            &#125;)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br></pre></td></tr></table></figure><p><input type="file"><br>        <canvas id="canvas"></canvas><br>        <div id="img" style="width:300px;height:300px;"></div><br>        <script><br>            $(“input”).on(‘input’,function(){<br>                let _this = this;<br>                var file = $(“input”)[0].files[0];<br>                var reader = new FileReader();<br>                reader.onload=function(){<br>                    var canvas = document.getElementById(“canvas”);<br>                    var context = canvas.getContext(“2d”);<br>                    var img = new Image();<br>                    img.src = this.result;<br>                    img.onload =function(){<br>                        this.width = this.width<em>0.2;<br>                        this.height = this.height</em>0.2;<br>                        invert(this,this.width,this.height);<br>                    };<br>                    function invert(img,w,h) {<br>                        canvas.width = w;<br>                        canvas.height = h;<br>                        context.drawImage(img,0,0,w,h);<br>                        var img1 = context.getImageData(0, 0, w, h);<br>                        var data = img1.data;<br>                        console.log(data)<br>                        var arr=[“M”,”N”,”H”,”Q”,”$”,”O”,”C”,”?”,”7”,”&gt;”,”!”,”:”,”–”,”;”,”.”];<br>                        var result=[];<br>                        for (var i = 0, len = data.length; i &lt; len; i += 4) {<br>                            var avg=(data[i]+data[i+1]+data[i+2])/3;<br>                            var num=Math.floor(avg/18);<br>                            result.push(arr[num]);<br>                            if((i+4)%(w*4)==0&amp;&amp;i!=0){<br>                                result.push(“<br/>“)<br>                            }<br>                        }<br>                        document.getElementById(“img”).innerHTML=result.join();<br>                    }<br>                }<br>                reader.readAsDataURL(file)<br>            })<br>        </script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js实现图片转成ASCII码&quot;&gt;&lt;a href=&quot;#js实现图片转成ASCII码&quot; class=&quot;headerlink&quot; title=&quot;js实现图片转成ASCII码&quot;&gt;&lt;/a&gt;js实现图片转成ASCII码&lt;/h1&gt;&lt;p&gt;之前有朋友问我微信头像（ASCII码构成的头
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>Antd的一些经验总结</title>
    <link href="http://yoursite.com/2018/06/15/Antd%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2018/06/15/Antd中的坑/</id>
    <published>2018-06-15T07:39:37.000Z</published>
    <updated>2018-06-15T09:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h1><p>这个月赶着做了一个汽车金融的后台评估系统，技术栈用的<code>react</code>+<code>react-redux</code>+<code>react-router</code>+<code>antd</code>+<code>webpack</code>,昨天新版本上线后总算有时间来总结总结了。Antd是蚂蚁金服的一个UI库，提供了各种各样的UI组件，方便开发者开发，提高开发效率。这里就总结一下在使用antd组件时遇到的一些问题。</p><h2 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h2><p>对于antd中form表单的使用其实碰到了很多问题（毕竟之前一直用的不多），对于实际业务中的需求来说，它基本满足了所有需求。</p><h3 id="表单的初始值（回显）"><a href="#表单的初始值（回显）" class="headerlink" title="表单的初始值（回显）"></a>表单的初始值（回显）</h3><p>实际业务中经常有编辑的操作，编辑操作必定要将之前编辑的数据展示在表单上，即<code>回显</code>。关于默认值的设置，antd不允许对表单组件用value或defaultValue两个属性来设置（仅仅针对使用了<code>getFieldDecorator</code>方法进行了绑定的组件），而推荐使用form属性下的<code>setFieldsValue</code>这个方法来设置默认值。由于不能用value或defaultValue来设值，所以对应的对于每个使用了<code>getFieldDEcorator</code>绑定了的组件可以用<code>getFieldValue</code>方法来获取相应的组件的值。</p><h3 id="表单校验规则"><a href="#表单校验规则" class="headerlink" title="表单校验规则"></a>表单校验规则</h3><p>实际业务中也经常要对用户输入的内容进行校验，除了校验表单是否必填，也会对表单输入内容做一些规则上的校验比如对于手机号码的校验，身份证的校验等等，这里可以通过form表单下的<code>getFieldDecorator</code>方法来进行设置，该方法有两个参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFieldDecorator(id, options) // 其中id是表单对应的name，options中可以设置一些参数用于对表单的限制</span><br></pre></td></tr></table></figure><p>另外想要进行的规则校验可以写在options下的rules属性，该属性是一个数组，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormItem &#123;...formItemLayout&#125; label=&#123;&apos;银行卡号&apos;&#125;&gt;</span><br><span class="line">    &#123;getFieldDecorator(&apos;cardId&apos;, &#123;</span><br><span class="line">            initialValue: id==&apos;add&apos;?&apos;&apos;:this.state.editData.accountNo,</span><br><span class="line">            rules: [&#123;type:&apos;string&apos;, required: true, message: &apos;请输入银行卡号&apos;&#125;,&#123;</span><br><span class="line">                validator: this.checkFormBankId,</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;)(</span><br><span class="line">        &lt;Input placeholder=&quot;请输入银行卡号&quot; maxLength=&quot;21&quot;&gt;&lt;/Input&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/FormItem&gt;</span><br></pre></td></tr></table></figure></p><p>在rules数组中有两个子元素，第一个中的type表示该字段的类型，通过这个方法包裹的组件的默认值的变量类型是不一样的，这个时候就可以通过这个字段来设置接收的变量类型，默认是<code>string</code>类型，除了string还可以选择如下类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string: Must be of type string. This is the default type.</span><br><span class="line">number: Must be of type number.</span><br><span class="line">boolean: Must be of type boolean.</span><br><span class="line">method: Must be of type function.</span><br><span class="line">regexp: Must be an instance of RegExp or a string that does not generate an exception when creating a new RegExp.</span><br><span class="line">integer: Must be of type number and an integer.</span><br><span class="line">float: Must be of type number and a floating point number.</span><br><span class="line">array: Must be an array as determined by Array.isArray.</span><br><span class="line">object: Must be of type object and not Array.isArray.</span><br><span class="line">enum: Value must exist in the enum.</span><br><span class="line">date: Value must be valid as determined by Date</span><br><span class="line">url: Must be of type url.</span><br><span class="line">hex: Must be of type hex.</span><br><span class="line">email: Must be of type email.</span><br></pre></td></tr></table></figure></p><p><code>required</code>表示该字段是否必填，<code>message</code>表示提示信息，当字段校验出错时会提示对应的内容。<br><code>validator</code>就是我们所需要做的规则校验，对应的校验规则可以写在你的方法中。</p><h2 id="Table表格"><a href="#Table表格" class="headerlink" title="Table表格"></a>Table表格</h2><p>对于antd中的Table表格操作的最多的其实是带checkbox的表格</p><h3 id="保留上一页的勾选"><a href="#保留上一页的勾选" class="headerlink" title="保留上一页的勾选"></a>保留上一页的勾选</h3><p>在开发过程中碰到过这种情况，在表格中勾选需要操作的选项后翻页，发现上页勾选的位置上这一页上也被勾选了，这显然是不科学的，造成这种现象的原因是有两点，一是表格数据是接口请求的并非一次性返回给你，因此下页数据请求过来后上页的数据没了，表格内部机制无法拿到的对应的行；二是没有给Table组件设置rowKeys属性，rowKeys属性可以用来让Table内部机制进行对行数据的筛选，一般rowKeys属性用行id来设置，这样可以保证每一行的rowkey不同，从而得到区分，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table className=&quot;che300-table&quot; rowSelection=&#123;rowSelection&#125; rowKey=&quot;projectId&quot; columns=&#123;columns&#125; dataSource=&#123;this.props.searchAftloanPkgData&#125; pagination=&#123;pkgPaConf&#125;&gt;&lt;/Table&gt;</span><br></pre></td></tr></table></figure><h2 id="树形组件"><a href="#树形组件" class="headerlink" title="树形组件"></a>树形组件</h2><p>对于antd的树形组件我一开始是很懵逼的，官方的文档demo写的不是很直观。</p><h3 id="如何定义每一个节点的key值"><a href="#如何定义每一个节点的key值" class="headerlink" title="如何定义每一个节点的key值"></a>如何定义每一个节点的key值</h3><p>树形组件的难点在于如何构建树形节点的key值，官方demo如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tree</span><br><span class="line">    checkable</span><br><span class="line">    defaultExpandedKeys=&#123;[&apos;0-0-0&apos;, &apos;0-0-1&apos;]&#125;</span><br><span class="line">    defaultSelectedKeys=&#123;[&apos;0-0-0&apos;, &apos;0-0-1&apos;]&#125;</span><br><span class="line">    defaultCheckedKeys=&#123;[&apos;0-0-0&apos;, &apos;0-0-1&apos;]&#125;</span><br><span class="line">    onSelect=&#123;this.onSelect&#125;</span><br><span class="line">    onCheck=&#123;this.onCheck&#125;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;TreeNode title=&quot;parent 1&quot; key=&quot;0-0&quot;&gt;</span><br><span class="line">        &lt;TreeNode title=&quot;parent 1-0&quot; key=&quot;0-0-0&quot; disabled&gt;</span><br><span class="line">        &lt;TreeNode title=&quot;leaf&quot; key=&quot;0-0-0-0&quot; disableCheckbox /&gt;</span><br><span class="line">        &lt;TreeNode title=&quot;leaf&quot; key=&quot;0-0-0-1&quot; /&gt;</span><br><span class="line">        &lt;/TreeNode&gt;</span><br><span class="line">        &lt;TreeNode title=&quot;parent 1-1&quot; key=&quot;0-0-1&quot;&gt;</span><br><span class="line">        &lt;TreeNode title=&#123;&lt;span style=&#123;&#123; color: &apos;#1890ff&apos; &#125;&#125;&gt;sss&lt;/span&gt;&#125; key=&quot;0-0-1-0&quot; /&gt;</span><br><span class="line">        &lt;/TreeNode&gt;</span><br><span class="line">    &lt;/TreeNode&gt;</span><br><span class="line">&lt;/Tree&gt;</span><br></pre></td></tr></table></figure></p><p>由于树形结构的层级结构，key的设置并不容易，所以前后端对于数据结构的讨论较多，具体什么数据结构就不说了，讲不清。。。。唯一的痛点就是数据结构，其他没什么。</p><h2 id="换肤，主题色的更改"><a href="#换肤，主题色的更改" class="headerlink" title="换肤，主题色的更改"></a>换肤，主题色的更改</h2><p>antd是默认的蓝白风格，这次后台系统是黄黑风格，因此需要对antd进行换肤，具体的教程官方也有，有两种方式，一种是用新的样式覆盖，另一种是用webpack，这里选择使用webpack，通过loader进行less全局变量的替换，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: require.resolve(&apos;less-loader&apos;),</span><br><span class="line">    options: &#123;</span><br><span class="line">        modifyVars: &#123;</span><br><span class="line">        &quot;@font-size-base&quot;: &apos;14px&apos;,</span><br><span class="line">        &quot;@table-padding-vertical&quot;: &apos;4px&apos;,</span><br><span class="line">        &quot;@table-padding-horizontal&quot;: &apos;4px&apos;,</span><br><span class="line">        &quot;@table-header-bg&quot;: &apos;#e9e9e9&apos;,</span><br><span class="line">        &quot;@primary-color&quot;: &quot;#ffc847&quot;,</span><br><span class="line">        &quot;@btn-primary-color&quot;: &quot;#333&quot;,</span><br><span class="line">        &quot;@text-color&quot;: &apos;#fff&apos;,</span><br><span class="line">        &quot;@layout-body-background&quot;: &apos;#2b2b2b&apos;,</span><br><span class="line">        &quot;@label-color&quot;: &apos;#fff&apos;,</span><br><span class="line">        &quot;@input-bg&quot;: &apos;#333&apos;,</span><br><span class="line">        &quot;@input-placeholder-color&quot;: &apos;#666&apos;,</span><br><span class="line">        &quot;@table-row-hover-bg&quot;: &apos;#534e41&apos;,</span><br><span class="line">        &quot;@component-background&quot;: &apos;#333&apos;,</span><br><span class="line">        &quot;@tag-default-bg&quot;: &apos;#ffc847&apos;,</span><br><span class="line">        &quot;@tag-default-color&quot;: &apos;#fff&apos;,</span><br><span class="line">        &quot;@item-hover-bg&quot;: &apos;#484235&apos;,</span><br><span class="line">        &quot;@background-color-base&quot;: &apos;#484235&apos;,</span><br><span class="line">        &quot;@item-active-bg&quot;: &apos;#484235&apos;,</span><br><span class="line">        &quot;@disabled-color&quot;: &apos;#ffc847&apos;,</span><br><span class="line">        &quot;@table-header-bg&quot;: &apos;#595959&apos;,</span><br><span class="line">        &quot;@heading-color&quot;: &apos;#fff&apos;,</span><br><span class="line">        &quot;@text-color-secondary&quot;: &apos;#fff&apos;,</span><br><span class="line">        &quot;@btn-default-color&quot;: &apos;#333&apos;,</span><br><span class="line">        &quot;@border-color-split&quot;: &apos;#595959&apos;,</span><br><span class="line">        &quot;@border-color-base&quot;: &apos;#666&apos;,</span><br><span class="line">        &quot;@background-color-active&quot;: &apos;#ffc847&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>edit by AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ant-Design&quot;&gt;&lt;a href=&quot;#Ant-Design&quot; class=&quot;headerlink&quot; title=&quot;Ant Design&quot;&gt;&lt;/a&gt;Ant Design&lt;/h1&gt;&lt;p&gt;这个月赶着做了一个汽车金融的后台评估系统，技术栈用的&lt;code&gt;react&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Antd" scheme="http://yoursite.com/tags/Antd/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
      <category term="Router" scheme="http://yoursite.com/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>h5、微信、小程序三端环境判断</title>
    <link href="http://yoursite.com/2018/05/11/h5%E3%80%81%E5%BE%AE%E4%BF%A1%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%89%E7%AB%AF%E7%8E%AF%E5%A2%83%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/05/11/h5、微信、小程序三端环境判断/</id>
    <published>2018-05-11T15:02:53.000Z</published>
    <updated>2018-05-11T15:25:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="h5、微信、小程序三端环境判断"><a href="#h5、微信、小程序三端环境判断" class="headerlink" title="h5、微信、小程序三端环境判断"></a>h5、微信、小程序三端环境判断</h1><p>这次的需求代码中存在兼容以上三端的情况，下文就如何判断这三个环境作详解（H5就不说了，没有判断的必要）。</p><h2 id="微信环境的判断"><a href="#微信环境的判断" class="headerlink" title="微信环境的判断"></a>微信环境的判断</h2><p>对于微信可以通过全局变量<code>WeixinJSBridge</code>来判断当前代码是否在微信环境下，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.WeixinJSBridge ? &apos;在微信&apos; ：&apos;不在微信&apos;</span><br></pre></td></tr></table></figure><p>但上述变量<code>WeixinJSBridge</code>并不会在执行代码时立刻挂载在<code>window</code>对象上，因此这个并不是一个最稳妥的判断方法，除非你执行上述代码的时候能保证<code>window</code>对象下已经挂载了这个变量。在不能确定是否存在这个变量时如果要判断当前是否在微信环境下，这里还有另外一个方法，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/MicroMessenger/.test(navigator.userAgent) ? &apos;在微信&apos; ：&apos;不在微信&apos;</span><br></pre></td></tr></table></figure><p>微信环境下的<code>navigator.userAgent</code>这个字符串中会存在<code>MicroMessenger</code>这个子字符串，因此可以通过上述方法在不确定<code>WeixinJSBridge</code>是否已挂载的情况下来判断是否是微信环境。</p><h2 id="小程序环境的判断"><a href="#小程序环境的判断" class="headerlink" title="小程序环境的判断"></a>小程序环境的判断</h2><p>对于小程序来说也有一个全局变量可以用来判断是否是小程序环境————<code>window.__wxjs_environment</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.__wxjs_environment ? &apos;在小程序&apos; ：&apos;不在小程序&apos;</span><br></pre></td></tr></table></figure><p>它和<code>WeixinJSBridge</code>一样并不能在第一时间获取到，中间也有一个挂载的过程，如果在尚未挂载之前要对环境进行判断则需要监听事件。</p><p>由于小程序的执行环境在微信程序中，所以可以通过监听<code>WeixinJSBridgeReady</code>事件来进行判断，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(!window.WeixinJSBridge || !WeixinJSBridge.invoke) &#123;  //首先判断当前是否存在微信桥</span><br><span class="line">    document.addEventListener(&apos;WeixinJSBridgeReady&apos;, function()&#123;    //微信桥不存在则监听微信桥准备事件</span><br><span class="line">        if(window.__wxjs_environment===&apos;miniprogram&apos;)&#123;   //当微信桥挂在上了之后则判断当前微信环境是否为小程序</span><br><span class="line">            console.log(&quot;在小程序&quot;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;在微信&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上为判断三端环境的详细说明</p><p>edit By AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;h5、微信、小程序三端环境判断&quot;&gt;&lt;a href=&quot;#h5、微信、小程序三端环境判断&quot; class=&quot;headerlink&quot; title=&quot;h5、微信、小程序三端环境判断&quot;&gt;&lt;/a&gt;h5、微信、小程序三端环境判断&lt;/h1&gt;&lt;p&gt;这次的需求代码中存在兼容以上三端的情
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="wxxcx" scheme="http://yoursite.com/tags/wxxcx/"/>
    
  </entry>
  
  <entry>
    <title>js移动端调用摄像头拍照并实现上传</title>
    <link href="http://yoursite.com/2018/05/11/js%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2018/05/11/js移动端调用摄像头拍照并实现上传/</id>
    <published>2018-05-11T11:25:40.000Z</published>
    <updated>2018-05-11T12:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js移动端调用摄像头拍照并实现上传"><a href="#js移动端调用摄像头拍照并实现上传" class="headerlink" title="js移动端调用摄像头拍照并实现上传"></a>js移动端调用摄像头拍照并实现上传</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次的需求功能中有一个用到手机拍照的功能，用户通过手机拍照从而识别图片中的信息，这个功能必然需要将图片上传到服务器，服务端实现图片的识别。（以下代码结合<code>Vue</code>）</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>图片拍摄</li></ul><p>js代码调用手机摄像头可以通过<code>input</code>标签的file类型来实现，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; multiple=&quot;multiple&quot; accept=&quot;image/*&quot; capture=&quot;camera&quot; @change=&quot;getImage&quot; ref=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure><p>通过这个方式可以成功调用手机的摄像头和相册选取功能（红米5只支持相册选取，小米的奇葩手机，磨人）；</p><ul><li>图片上传</li></ul><p>图片上传这里就有问题了，直接上传图片是不现实的，现在的手机像素都很高，拍照的图片质量必然很大，直接上传服务器并不显示，在这里就需要将图片进行压缩。</p><p>图片压缩可以通过两种方式：</p><ul><li>一种是服务端进行操作，比如七牛云或者阿里云的图片处理，但是现在的场景下并不可能；</li><li>另一种是客户端处理，通过canvas来降低图片质量，进行图片压缩。</li></ul><p>很显然是选择下面一种，直接上代码不bb</p><p><code>HTML部分</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;dealPic&quot; style=&quot;display:none;&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></p><p><code>JS部分</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let _this = this;</span><br><span class="line">let img = new Image();</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">reader.onload = function()&#123;</span><br><span class="line">    _this.base64Img = this.result; //在这里获取base64码</span><br><span class="line">    img.src = _this.base64Img;</span><br><span class="line">    img.onload=function()&#123;</span><br><span class="line">        let canvas = document.getElementById(&apos;dealPic&apos;);</span><br><span class="line">        let context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        context.scale(0.4,0.4); </span><br><span class="line">        canvas.width = img.width*0.4;</span><br><span class="line">        canvas.height = img.height*0.4; </span><br><span class="line">        context.drawImage(img, 0, 0, img.width*0.4, img.height*0.4);    //缩小画布，毕竟手机拍下来的图片都是几千像素乘几千像素的大小</span><br><span class="line">        _this.base64Img = canvas.toDataURL(_this.$refs.file.files[0].type,0.5);     //canvas生成后通过toDataURL获取canvas 处理后的其base64码，并自定义其画质，此处是0.5</span><br><span class="line">        let PicBlob = _this.getBlobBydataURI(_this.base64Img,_this.$refs.file.files[0].type); //转成文件流方便上传服务器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader.readAsDataURL(_this.$refs.file.files[0]);</span><br></pre></td></tr></table></figure></p><p>到此，通过实验已经将原7M大小的照片转成了200多K,画质上来讲差的也不是太多,这样上传图片服务器压力就小了很多很多，用户体验也就更好。</p><h3 id="在压缩一步"><a href="#在压缩一步" class="headerlink" title="在压缩一步"></a>在压缩一步</h3><p>其实200多K还是很大，虽然相比于原来的7M来说是小了很多，但是相信很多人和我一样希望能够在保证图片质量的情况下再缩小图片大小，这个是可行的，上面介绍了两种方法来压缩图片，我们完全可以在客户端压缩图片后再上传服务器来进行图片的处理。因为公司用的是七牛云，所以这里介绍下七牛云的服务端图片处理。</p><p>其实很简单就分两步：<code>上传七牛云服务器</code>和<code>图片地址加参</code></p><p>上传七牛云就不说了，这里介绍下<code>图片地址加参</code>。</p><p>七牛云的图片处理服务为七牛云上的图片文件提供以下功能：</p><ul><li>对图片进行缩略操作</li><li>图片缩放、裁剪、旋转</li><li>获取图片格式、大小、色彩模型信息</li><li>提供数码相机照片的可交换图像文件格式</li><li>图片添加图片、文字、图文混合水印</li><li>计算图片的平均色调</li></ul><p>接口如下：</p><table><thead><tr><th>接口</th><th>简介</th></tr></thead><tbody><tr><td>imageslim</td><td>图片瘦身（imageslim）将存储在七牛的JPEG、PNG格式的图片实时压缩而尽可能不影响画质。</td></tr><tr><td>imageView2</td><td>图片基本处理接口可对图片进行缩略操作，生成各种缩略图。imageView2 接口可支持处理的原图片格式有 psd、jpeg、png、gif、webp、tiff、bmp。</td></tr></tbody></table><p>七牛提供了很多图片处理的接口，这里我用的是imageView2这个接口来进行图片操作；</p><h4 id="接口规格"><a href="#接口规格" class="headerlink" title="接口规格"></a>接口规格</h4><p>注意：接口规格不含任何空格与换行符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imageView2/&lt;mode&gt;/w/&lt;LongEdge&gt;</span><br><span class="line">                 /h/&lt;ShortEdge&gt;</span><br><span class="line">                 /format/&lt;Format&gt;</span><br><span class="line">                 /interlace/&lt;Interlace&gt;</span><br><span class="line">                 /q/&lt;Quality&gt;</span><br><span class="line">                 /ignore-error/&lt;ignoreError&gt;</span><br></pre></td></tr></table></figure></p><p>上面一次往下是长，宽，输出格式，渐进显示，图片质量以及失败返回等参数。</p><p>其中 <code>&lt;mode&gt;</code> 分为如下几种情况:</p><table><thead><tr><th>接口</th><th>简介</th></tr></thead><tbody><tr><td><code>/0/w/&lt;LongEdge&gt;/h/&lt;ShortEdge&gt;</code></td><td>限定缩略图的长边最多为<longedge>，短边最多为<shortedge>，进行等比缩放，不裁剪。如果只指定 w 参数则表示限定长边（短边自适应），只指定 h 参数则表示限定短边（长边自适应）</shortedge></longedge></td></tr><tr><td><code>/1/w/&lt;Width&gt;/h/&lt;Height&gt;</code></td><td>限定缩略图的宽最少为<width>，高最少为<height>，进行等比缩放，居中裁剪。转后的缩略图通常恰好是 <width>x<height> 的大小（有一个边缩放的时候会因为超出矩形框而被裁剪掉多余部分）。如果只指定 w 参数或只指定 h 参数，代表限定为长宽相等的正方图。</height></width></height></width></td></tr><tr><td><code>/2/w/&lt;Width&gt;/h/&lt;Height&gt;</code></td><td>限定缩略图的宽最多为<width>，高最多为<height>，进行等比缩放，不裁剪。如果只指定 w 参数则表示限定宽（长自适应），只指定 h 参数则表示限定长（宽自适应）。它和模式0类似，区别只是限定宽和高，不是限定长边和短边。从应用场景来说，模式0适合移动设备上做缩略图，模式2适合PC上做缩略图。</height></width></td></tr><tr><td><code>/3/w/&lt;Width&gt;/h/&lt;Height&gt;</code></td><td>限定缩略图的宽最少为<width>，高最少为<height>，进行等比缩放，不裁剪。如果只指定 w 参数或只指定 h 参数，代表长宽限定为同样的值。你可以理解为模式1是模式3的结果再做居中裁剪得到的。</height></width></td></tr><tr><td><code>/4/w/&lt;LongEdge&gt;/h/&lt;ShortEdge&gt;</code></td><td>限定缩略图的长边最少为<longedge>，短边最少为<shortedge>，进行等比缩放，不裁剪。如果只指定 w 参数或只指定 h 参数，表示长边短边限定为同样的值。这个模式很适合在手持设备做图片的全屏查看（把这里的长边短边分别设为手机屏幕的分辨率即可），生成的图片尺寸刚好充满整个屏幕（某一个边可能会超出屏幕）。</shortedge></longedge></td></tr><tr><td><code>/5/w/&lt;LongEdge&gt;/h/&lt;ShortEdge&gt;</code></td><td>限定缩略图的长边最少为<longedge>，短边最少为<shortedge>，进行等比缩放，居中裁剪。如果只指定 w 参数或只指定 h 参数，表示长边短边限定为同样的值。同上模式4，但超出限定的矩形部分会被裁剪。</shortedge></longedge></td></tr></tbody></table><p>由于要考虑到图像识别的问题，图片不能被处理地太过变样，因此采取第一个接口<code>/0/w/&lt;LongEdge&gt;/h/&lt;ShortEdge&gt;</code>，图片长宽方面只是进行等比缩放。</p><p>上面说了除了长宽，还可以对质量进行处理，<code>/q/0.5</code>这个表示50%的质量，取值在0～1之间。</p><p>综上是这次移动端调用手机摄像头的经验之谈，踩坑之旅。</p><p>edit By AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js移动端调用摄像头拍照并实现上传&quot;&gt;&lt;a href=&quot;#js移动端调用摄像头拍照并实现上传&quot; class=&quot;headerlink&quot; title=&quot;js移动端调用摄像头拍照并实现上传&quot;&gt;&lt;/a&gt;js移动端调用摄像头拍照并实现上传&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Redux异步处理之Redux-thunk与Redux-saga</title>
    <link href="http://yoursite.com/2018/04/23/Redux%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B9%8BRedux-thunk%E4%B8%8ERedux-saga/"/>
    <id>http://yoursite.com/2018/04/23/Redux异步处理之Redux-thunk与Redux-saga/</id>
    <published>2018-04-23T06:23:07.000Z</published>
    <updated>2018-05-05T13:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux异步处理之-Redux-thunk与Redux-saga"><a href="#Redux异步处理之-Redux-thunk与Redux-saga" class="headerlink" title="Redux异步处理之 Redux-thunk与Redux-saga"></a>Redux异步处理之 Redux-thunk与Redux-saga</h1><h2 id="Redux异步"><a href="#Redux异步" class="headerlink" title="Redux异步"></a>Redux异步</h2><p>众所周知，redux中所有的dispatch都是同步的，而处理ajax或fetch之类的异步请求一般要分为三步。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action:"></a>Action:</h3><p>需要写三个action来处理——fetching、fetched、error这三步，请看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; type:&apos;FETCH_POSTS_REQUEST&apos;&#125;//发起请求</span><br><span class="line">&#123; type:&apos;FETCH_POSTS_FAILURE&apos;, payload: &apos;errorInfo&apos; &#125;//请求失败</span><br><span class="line">&#123; type:&apos;FETCH_POSTS_SUCCESS&apos;, payload:&#123;data&#125;//请求成功并且获取到数据</span><br></pre></td></tr></table></figure></p><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer:"></a>Reducer:</h3><p>同样需要写三个对应的reduce来进行对state的处理以及合并，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let reducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">switch(action.type) &#123;</span><br><span class="line">//发起请求时reducer的处理</span><br><span class="line">case &apos;FETCH_POSTS_REQUEST&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: true&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//请求失败时的处理</span><br><span class="line">case &apos;FETCH_POSTS_FAILURE&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: false, error: action.payload&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//请求成功</span><br><span class="line">case &apos;FETCH_POSTS_SUCCESS&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: false, fetched: true, users: action.payload&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何进行dispatch"><a href="#如何进行dispatch" class="headerlink" title="如何进行dispatch"></a>如何进行dispatch</h3><p>由于dispatch是同步操作，reducer中又是以纯函数的形式进行代码编写，不能往里面加入其它带有操作性质的代码，因此异步的操作我们需要借助中间件来完成。<br>redux中 <code>applyMiddleware</code> 用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(</span><br><span class="line">reducer,</span><br><span class="line">applyMiddleware(...middlewares)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>为了了解中间件到底做了些什么，先来看下源码：</p><h4 id="applyMiddleware："><a href="#applyMiddleware：" class="headerlink" title="applyMiddleware："></a>applyMiddleware：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function applyMiddleware() &#123;</span><br><span class="line">for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) &#123;</span><br><span class="line">middlewares[_key] = arguments[_key];</span><br><span class="line">&#125;//定义一个middlewares数组，长度和入参相同，并且将入参传入该数组中</span><br><span class="line">return function (createStore) &#123;//这里的creatStore即前面的creatStore方法</span><br><span class="line">return function (reducer, preloadedState, enhancer) &#123;//这里的enhancer可以就当成是中间件</span><br><span class="line">var store = createStore(reducer, preloadedState, enhancer);</span><br><span class="line">var _dispatch = store.dispatch;</span><br><span class="line">var chain = [];</span><br><span class="line">var middlewareAPI = &#123;</span><br><span class="line">getState: store.getState,</span><br><span class="line">dispatch: function dispatch(action) &#123;</span><br><span class="line">return _dispatch(action);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">chain = middlewares.map(function (middleware) &#123;</span><br><span class="line">return middleware(middlewareAPI);</span><br><span class="line">&#125;);//我们可以看下chain里面是个什么东西</span><br><span class="line">_dispatch = compose.apply(undefined, chain)(store.dispatch);//嵌套执行中间件的组合逻辑（因此才有中间件执行顺序一说）</span><br><span class="line">return _extends(&#123;&#125;, store, &#123;</span><br><span class="line">dispatch: _dispatch //说白了中间件实际上就是改造了dispatch</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="compose："><a href="#compose：" class="headerlink" title="compose："></a>compose：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Composes single-argument functions from right to left. The rightmost</span><br><span class="line">* function can take multiple arguments as it provides the signature for</span><br><span class="line">* the resulting composite function.</span><br><span class="line">*</span><br><span class="line">* @param &#123;...Function&#125; funcs The functions to compose.</span><br><span class="line">* @returns &#123;Function&#125; A function obtained by composing the argument functions</span><br><span class="line">* from right to left. For example, compose(f, g, h) is identical to doing</span><br><span class="line">* (...args) =&gt; f(g(h(...args))).</span><br><span class="line">*/</span><br><span class="line">function compose() &#123;</span><br><span class="line">for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key &lt; _len; _key++) &#123;</span><br><span class="line">funcs[_key] = arguments[_key];</span><br><span class="line">&#125;</span><br><span class="line">if (funcs.length === 0) &#123;</span><br><span class="line">return function (arg) &#123;</span><br><span class="line">return arg;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//如果长度为1，返回该函数</span><br><span class="line">if (funcs.length === 1) &#123;</span><br><span class="line">return funcs[0];</span><br><span class="line">&#125;</span><br><span class="line">//核心语句reduce嵌套执行所有的函数最后返回一个最终函数</span><br><span class="line">return funcs.reduce(function (a, b) &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">return a(b.apply(undefined, arguments));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上其实compose嵌套执行的函数实际上就是类似下面这个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function f1(next) &#123;</span><br><span class="line">return function() &#123;</span><br><span class="line">console.log(&apos;f1 start&apos;)</span><br><span class="line">next()</span><br><span class="line">console.log(&apos;f1 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function f2(next) &#123;</span><br><span class="line">return function() &#123;</span><br><span class="line">console.log(&apos;f2 start&apos;)</span><br><span class="line">next()</span><br><span class="line">console.log(&apos;f2 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function f() &#123;</span><br><span class="line">console.log(&apos;heart&apos;)</span><br><span class="line">&#125;</span><br><span class="line">f1(f2(f))() //所以最后的综合逻辑函数就是类似这种M1(M2(dispatch))(action)</span><br></pre></td></tr></table></figure><h4 id="creatStore："><a href="#creatStore：" class="headerlink" title="creatStore："></a>creatStore：</h4><p>中间件有关的主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) &#123;</span><br><span class="line">enhancer = preloadedState</span><br><span class="line">preloadedState = undefined</span><br><span class="line">&#125;</span><br><span class="line">if (typeof enhancer !== &apos;undefined&apos;) &#123;</span><br><span class="line">if (typeof enhancer !== &apos;function&apos;) &#123;</span><br><span class="line">throw new Error(&apos;Expected the enhancer to be a function.&apos;)</span><br><span class="line">&#125;</span><br><span class="line">return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">&#125;</span><br><span class="line">if (typeof reducer !== &apos;function&apos;) &#123;</span><br><span class="line">throw new Error(&apos;Expected the reducer to be a function.&apos;)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>redux的applyMiddle就分析到这边，在了解了这个得基础上，下面就来介绍两个常用的异步流处理的中间件，<code>redux-thunk</code>和 <code>redux-saga</code>，本文就这两个中间件进行探讨和比较其中优劣。</p><h2 id="认识Redux-thunk"><a href="#认识Redux-thunk" class="headerlink" title="认识Redux-thunk"></a>认识Redux-thunk</h2><p>redux-thunk的官方文档是这样介绍的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从异步的角度，Thunk 是指一切都就绪的会返回某些值的函数。你不用传任何参数，你只需调用它，它便会返回相应的值。</span><br></pre></td></tr></table></figure><p>本栗子结合thunk的使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//此处dispatch的不是一个action对象而是一个函数</span><br><span class="line">store.dispatch((url)=&gt;(dispatch)=&gt;&#123;</span><br><span class="line">dispatch(&#123;</span><br><span class="line">type:&apos;FETCH_POSTS_REQUEST&apos;</span><br><span class="line">&#125;);//发起请求(象征性的触发一下，表示我准备开始请求了，其实个人感觉不写都无所谓，只是改变了一下fetching的值而已#滑稽)</span><br><span class="line">fetch(url).then(data =&gt; dispatch(&#123;</span><br><span class="line">type:&apos;FETCH_POSTS_SUCCESS&apos;,</span><br><span class="line">payload:data</span><br><span class="line">&#125;));//请求成功后更新state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因此，从上述代码可以看出<code>redux-thunk</code> 的主要思想是扩展 action，使得 action 从一个对象变成一个函数，并且触发dispatch都是从UI进行触发，逻辑都是写在UI。</p><p>那么为什么thunk可以传递一个函数，这里我们来看下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line">return action(dispatch, getState, extraArgument);</span><br><span class="line">&#125;</span><br><span class="line">//这里的意思是指如果这个action是函数，那么就执行它，否则next</span><br><span class="line">return next(action);//将此action传递到下一个middleware</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure><p>但由此可以看出redux-thunk的缺点：</p><ul><li>action 虽然扩展了，但因此变得复杂，后期可维护性降低；</li><li>thunks 内部测试逻辑比较困难，需要mock所有的触发函数（ <code>主要因素</code>）；</li><li>协调并发任务比较困难，当自己的 action 调用了别人的 action，别人的 action 发生改动，则需要自己主动修改；</li><li>业务逻辑会散布在不同的地方：启动的模块，组件以及thunks内部。（<code>主要因素</code>）；</li></ul><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123;applyMiddleware, createStore&#125; from &apos;redux&apos;;</span><br><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">const initialState = &#123; fetching: false, fetched: false, users: [], error: null &#125;</span><br><span class="line">const reducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">switch(action.type) &#123;</span><br><span class="line">case &apos;FETCH_POSTS_REQUEST&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: true&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case &apos;FETCH_POSTS_FAILURE&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: false, error: action.payload&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case &apos;FETCH_POSTS_SUCCESS&apos;: &#123;</span><br><span class="line">return &#123;...state, fetching: false, fetched: true, users: action.payload&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line">const middleware = applyMiddleware(thunk);</span><br><span class="line">store.dispatch((dispatch) =&gt; &#123;</span><br><span class="line">dispatch(&#123;type: &apos;FETCH_POSTS_REQUEST&apos;&#125;);</span><br><span class="line">axios.get(&apos;./data.json&apos;).then((response) =&gt; &#123;</span><br><span class="line">dispatch(&#123;type: &apos;FETCH_POSTS_SUCCESS&apos;, payload: response.data&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">dispatch(&#123;type: &apos;FETCH_POSTS_FAILURE&apos;, payload: err&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="认识Redux-saga"><a href="#认识Redux-saga" class="headerlink" title="认识Redux-saga"></a>认识Redux-saga</h2><p>首先什么是saga？<br><code>saga，这个术语常用于CQRS架构，代表查询与责任分离。</code></p><p>saga的作者是个搞房地产的，业余时间写写代码，和阮一峰有点像。</p><p>官方的介绍是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redux-saga 是一个旨在使应用程序副作用（即数据获取等异步操作和获取浏览器缓存等非纯函数操作）更容易管理，执行更有效率，容易测试和解决错误的库。这个构思模型是一个saga就像一个应用程序中仅仅用于解决这些副作用的单线程。</span><br><span class="line">redux-saga是一个redux中间件，具有完全访问redux应用状态，也可以迅速处理redux action，这意味着这个线程可以被主程序中的正常redux action启动、暂停和取消。它利用了es6之中的generators的特点来使这些异步数据流容易读取、写入和测试。这样做，这些异步数据流看起来就像是你的标准的同步JavaScript代码。（类似于async/await），除此之外，generators有一些我们需要的令人惊叹的特征。</span><br></pre></td></tr></table></figure><p>redux-saga 将异步任务进行了集中处理，且方便测试。</p><p>所有的东西都必须被封装在 sagas 中。sagas 包含3个部分，用于联合执行任务：</p><ul><li><code>worker saga</code> ：做所有的工作，如调用 API，进行异步请求，并且获得返回结果。</li><li><code>watcher saga</code> ：监听被 dispatch 的 actions，当接收到 action 或者知道其被触发时，调用 worker saga 执行任务。</li><li><code>root saga</code> ：立即启动 sagas 的唯一入口</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>使用createSagaMiddleware方法创建saga 的Middleware，然后在创建的redux的store时，使用applyMiddleware函数将创建的sagaMiddleware实例绑定到store上，最后可以调用saga Middleware的run函数来执行某个或者某些Middleware。</li><li>在saga的Middleware中，可以使用takeEvery或者takeLatest等API来监听某个action，当某个action触发后，saga可以使用call、fetch等api发起异步操作，操作完成后使用put函数触发action，同步更新state，从而完成整个State的更新。<br>首先需要启动saga，启动saga一般都写在入口文件中，下面是个栗子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware&#125; from &apos;redux&apos;;</span><br><span class="line">import createSagaMiddleware from &apos;redux-saga&apos;;</span><br><span class="line">import appReducer from &apos;./reducers&apos;;</span><br><span class="line">const sagaMiddleware = createSagaMiddleware();</span><br><span class="line">const middlewares = [sagaMiddleware];</span><br><span class="line">const store = createStore(appReducer,applyMiddleware(...middlewares));</span><br><span class="line">sagaMiddleware.run(rootSaga);//saga一旦执行就会永远执行下去</span><br><span class="line">render(</span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">&lt;App /&gt;</span><br><span class="line">&lt;/Provider&gt;,</span><br><span class="line">document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，就可以在 sagas 文件夹中集中写 saga 文件了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; take, fork, call, put &#125; from &apos;redux-saga/effects&apos;;</span><br><span class="line">//执行函数即work saga</span><br><span class="line">function* fetchUrl(url) &#123;</span><br><span class="line">try&#123;//利用try-catch来捕获异常</span><br><span class="line">const data = yield call(fetch, url); // 指示中间件调用 fetch 异步任务</span><br><span class="line">yield put(&#123; type: &apos;FETCH_POSTS_SUCCESS&apos;, payload:data &#125;); // 指示中间件发起一个 action 到 Store</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">yield put(&#123; type: &apos;FETCH_POSTS_FAILURE&apos;, payload:error &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 监听函数即watch saga</span><br><span class="line">function* watchFetchRequests() &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">const action = yield take(&apos;FETCH_POSTS_REQUEST&apos;); // 指示中间件等待 Store 上指定的 action，即监听 action</span><br><span class="line">yield fork(fetchUrl, action.url); // 指示中间件以无阻塞调用方式执行 fetchUrl</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 redux-saga 中的基本概念就是：sagas 自身不真正执行副作用（如函数 call），但是会构造一个需要执行副作用的描述。中间件会执行该副作用并把结果返回给 generator 函数。<br>对于sages ，采用 Generator 函数来 yield Effects（包含指令的文本对象）。Generator 函数的作用是可以暂停执行，再次执行的时候从上次暂停的地方继续执行。Effect 是一个简单的对象，该对象包含了一些给 middleware 解释执行的信息。你可以通过使用 effects API 如 fork，call，take，put，cancel 等来创建 Effect。</p><p>关于Effect官方是这样解释的:</p><p><code>在 redux-saga 的世界里，Sagas 都用 Generator 函数实现。我们从 Generator 里 yield 纯 JavaScript 对象以表达 Saga 逻辑。 我们称呼那些对象为 Effect。Effect 是一个简单的对象，这个对象包含了一些给 middleware 解释执行的信息。 你可以把 Effect 看作是发送给middleware 的指令以执行某些操作（调用某些异步函数，发起一个 action 到 store）。</code></p><p>对上述例子的说明：</p><ul><li>引入的 redux-saga/effects 都是纯函数，每个函数构造一个特殊的对象，其中包含着中间件需要执行的指令，如：call(fetchUrl, url) 返回一个类似于 {type: CALL, function: fetchUrl, args: [url]} 的对象。</li><li>在 watcher saga watchFetchRequests中：<br>首先 yield take(‘FETCH_REQUEST’) 来告诉中间件我们正在等待一个类型为 FETCH_REQUEST 的 action，然后中间件会暂停执行<br>wacthFetchRequests generator 函数，直到 FETCH_REQUEST action 被 dispatch。一旦我们获得了匹配的 action，中间件就会恢复执行 generator 函数。下一条指令 fork(fetchUrl, action.url) 告诉中间件去无阻塞调用一个新的 fetchUrl 任务，action.url 作为 fetchUrl 函数的参数传递。中间件会触发 fetchUrl generator 并且不会阻塞 watchFetchRequests。当fetchUrl 开始执行的时候，watchFetchRequests会继续监听其它的 watchFetchRequests actions。当然，JavaScript 是单线程的，redux-saga 让事情看起来是同时进行的。</li><li>在 worker saga fetchUrl 中，call(fetch,url) 指示中间件去调用 fetch 函数，同时，会阻塞fetchUrl 的执行，中间件会停止 generator 函数，直到 fetch 返回的 Promise 被 resolved（或 rejected），然后才恢复执行 generator 函数。</li></ul><p>这里我们可以来看一波源码，搞清楚这个Effect到底是什么。<br>对于Effect对象的定义，写在了 <code>redux-saga/src/internal/io.js</code> 文件中，下面是Effect的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const effect = (type, payload) =&gt; (&#123; [IO]: true, [type]: payload &#125;);</span><br></pre></td></tr></table></figure><p>很简单就一句话，表明这个effect其实就是返回了一个对象。</p><p>接下来看看所谓的put和call到底是个什么东西</p><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export function put(channel, action) &#123;</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">if (arguments.length &gt; 1) &#123;</span><br><span class="line">check(channel, is.notUndef, &apos;put(channel, action): argument channel is undefined&apos;)</span><br><span class="line">check(channel, is.channel, `put(channel, action): argument $&#123;channel&#125; is not a valid channel`)</span><br><span class="line">check(action, is.notUndef, &apos;put(channel, action): argument action is undefined&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">check(channel, is.notUndef, &apos;put(action): argument action is undefined&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (is.undef(action)) &#123;</span><br><span class="line">action = channel</span><br><span class="line">channel = null</span><br><span class="line">&#125;</span><br><span class="line">return effect(PUT, &#123; channel, action &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getFnCallDesc(meth, fn, args) &#123;</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">check(fn, is.notUndef, `$&#123;meth&#125;: argument fn is undefined`)</span><br><span class="line">&#125;</span><br><span class="line">let context = null</span><br><span class="line">if (is.array(fn)) &#123;</span><br><span class="line">[context, fn] = fn</span><br><span class="line">&#125; else if (fn.fn) &#123;</span><br><span class="line">(&#123; context, fn &#125; = fn)</span><br><span class="line">&#125;</span><br><span class="line">if (context &amp;&amp; is.string(fn) &amp;&amp; is.func(context[fn])) &#123;</span><br><span class="line">fn = context[fn]</span><br><span class="line">&#125;</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">check(fn, is.func, `$&#123;meth&#125;: argument $&#123;fn&#125; is not a function`)</span><br><span class="line">&#125;</span><br><span class="line">return &#123; context, fn, args &#125;</span><br><span class="line">&#125;</span><br><span class="line">export function call(fn, ...args) &#123;</span><br><span class="line">return effect(CALL, getFnCallDesc(&apos;call&apos;, fn, args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出乎意料都是只返回了一个纯对象（ <code>先不管细节</code> ）。<br>effect返回的纯对象由于generate函数的机制会将yield的控制权交给外部，用来给generator外层的执行容器task( <code>这东西我讲不清楚所以就不讲了</code> )发送一个信号，告诉task该做什么。task在接收到effect发出的指令后将会执行下面这段函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function next(arg, isErr) &#123;</span><br><span class="line">// Preventive measure. If we end up here, then there is really something wrong</span><br><span class="line">if (!mainTask.isRunning) &#123;</span><br><span class="line">throw new Error(&apos;Trying to resume an already finished generator&apos;)</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">let result</span><br><span class="line">if (isErr) &#123;</span><br><span class="line">result = iterator.throw(arg)</span><br><span class="line">&#125; else if (arg === TASK_CANCEL) &#123;</span><br><span class="line">/**</span><br><span class="line">getting TASK_CANCEL automatically cancels the main task</span><br><span class="line">We can get this value here</span><br><span class="line">- By cancelling the parent task manually</span><br><span class="line">- By joining a Cancelled task</span><br><span class="line">**/</span><br><span class="line">mainTask.isCancelled = true</span><br><span class="line">/**</span><br><span class="line">Cancels the current effect; this will propagate the cancellation down to any called tasks</span><br><span class="line">**/</span><br><span class="line">next.cancel()</span><br><span class="line">/**</span><br><span class="line">If this Generator has a `return` method then invokes it</span><br><span class="line">This will jump to the finally block</span><br><span class="line">**/</span><br><span class="line">result = is.func(iterator.return) ? iterator.return(TASK_CANCEL) : &#123; done: true, value: TASK_CANCEL &#125;</span><br><span class="line">&#125; else if (arg === CHANNEL_END) &#123;</span><br><span class="line">// We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap</span><br><span class="line">End of channels)</span><br><span class="line">result = is.func(iterator.return) ? iterator.return() : &#123; done: true &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result = iterator.next(arg)//这里将会执行generator并将结果赋值给result</span><br><span class="line">&#125;</span><br><span class="line">if (!result.done) &#123;//这里会判断这个generator是否执行完毕</span><br><span class="line">runEffect(result.value, parentEffectId, &apos;&apos;, next) //这里的runEffect就是各种执行结果的返回（全部流程到此结束）</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/**</span><br><span class="line">This Generator has ended, terminate the main task and notify the fork queue</span><br><span class="line">**/</span><br><span class="line">mainTask.isMainRunning = false</span><br><span class="line">mainTask.cont &amp;&amp; mainTask.cont(result.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">if (mainTask.isCancelled) &#123;</span><br><span class="line">log(&apos;error&apos;, `uncaught at $&#123;name&#125;`, error.message)</span><br><span class="line">&#125;</span><br><span class="line">mainTask.isMainRunning = false</span><br><span class="line">mainTask.cont(error, true)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redux-saga优点"><a href="#Redux-saga优点" class="headerlink" title="Redux-saga优点"></a>Redux-saga优点</h3><ul><li>声明式 Effects：所有的操作以JavaScript对象的方式被 yield，并被 middleware 执行。使得在 saga 内部测试变得更加容易，可以通过简单地遍历 Generator 并在 yield 后的成功值上面做一个 deepEqual 测试。</li><li>高级的异步控制流以及并发管理：可以使用简单的同步方式描述异步流，并通过 fork(无阻塞) 实现并发任务。</li><li>架构上的优势：将所有的异步流程控制都移入到了 sagas，UI 组件不用执行业务逻辑，只需 dispatch action 就行，增强组件复用性。</li></ul><p>Edit by 张真欣</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redux异步处理之-Redux-thunk与Redux-saga&quot;&gt;&lt;a href=&quot;#Redux异步处理之-Redux-thunk与Redux-saga&quot; class=&quot;headerlink&quot; title=&quot;Redux异步处理之 Redux-thunk与Red
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>日常Js学习汇总(2)</title>
    <link href="http://yoursite.com/2018/04/13/%E6%97%A5%E5%B8%B8Js%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB(2)/"/>
    <id>http://yoursite.com/2018/04/13/日常Js学习汇总(2)/</id>
    <published>2018-04-13T08:30:45.000Z</published>
    <updated>2018-04-13T14:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常Js学习汇总-2"><a href="#日常Js学习汇总-2" class="headerlink" title="日常Js学习汇总(2)"></a>日常Js学习汇总(2)</h1><p>最近搞项目改版，存在新老需求，这次就项目内遇到的一些问题和学习到的新知识做一个笔记。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>主要是设置<code>cookie</code>和删除<code>cookie</code>的问题，一般设置<code>cookie</code>可以如下设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = `$&#123;&quot;cookie名&quot;&#125;=$&#123;&quot;cookie值&quot;&#125;;expires=$&#123;&quot;cookie生命时间&quot;&#125;;domain=$&#123;&quot;存储域名&quot;&#125;;path=$&#123;&quot;相对路径&quot;&#125;`;</span><br></pre></td></tr></table></figure><p>或者用<code>jquery.cookie</code>这个库来设置(主要就是方便点，不用拼那么长字符串)，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(&quot;cookie名&quot;,&quot;cookie值&quot;,&#123;expires:&apos;cookie生命时间&apos;,domain:&apos;存储域名&apos;,path:&apos;相对路径&apos;&#125;);</span><br></pre></td></tr></table></figure><p>实现上没什么难度，但是在项目中代码执行后偏偏没有在控制台中看到存入的cookie,很蛋疼。</p><p>最后发现问题出在domain上。项目里是区分环境的，不同的环境存入不同的域名，其实这也不是问题，问题是我设置的是测试环境的域名，但是我看代码效果的时候去的是docker。。。。。瞬间感觉自己的智商被清零了。。。。。。主要还是当初试着在控制台里输入了上述代码，控制台里确实也存入了和当前域名不一样的域名的cookie，被这个坑惨了，而且至今都不知道为什么在控制台写可以存不同域名的cookie但是代码里就存不进去。</p><h2 id="mescroll插件问题"><a href="#mescroll插件问题" class="headerlink" title="mescroll插件问题"></a>mescroll插件问题</h2><p>新需求中有个顶部下拉刷新，底部上拉加载的功能，这里使用了mescroll这个插件，demo示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">var mescroll = new MeScroll(&quot;mescroll&quot;, &#123;</span><br><span class="line">    down: &#123;</span><br><span class="line">        auto: false, //是否在初始化完毕之后自动执行下拉回调callback; 默认true</span><br><span class="line">        callback: downCallback //下拉刷新的回调</span><br><span class="line">    &#125;,</span><br><span class="line">    up: &#123;</span><br><span class="line">        auto: true, //是否在初始化时以上拉加载的方式自动加载第一页数据; 默认false</span><br><span class="line">        isBounce: false, //此处禁止ios回弹,解析(务必认真阅读,特别是最后一点): http://www.mescroll.com/qa.html#q10</span><br><span class="line">        callback: upCallback, //上拉回调,此处可简写; 相当于 callback: function (page) &#123; upCallback(page); &#125;</span><br><span class="line">        toTop:&#123; //配置回到顶部按钮</span><br><span class="line">            src : &quot;../res/img/mescroll-totop.png&quot;, //默认滚动到1000px显示,可配置offset修改</span><br><span class="line">            //offset : 1000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">function downCallback()&#123;</span><br><span class="line">    //联网加载数据</span><br><span class="line">    getListDataFromNet(0, 1, function(data)&#123;</span><br><span class="line">        //联网成功的回调,隐藏下拉刷新的状态</span><br><span class="line">        mescroll.endSuccess();</span><br><span class="line">        //设置列表数据</span><br><span class="line">        setListData(data, false);</span><br><span class="line">    &#125;, function()&#123;</span><br><span class="line">        //联网失败的回调,隐藏下拉刷新的状态</span><br><span class="line">        mescroll.endErr();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function upCallback(page)&#123;</span><br><span class="line">    //联网加载数据</span><br><span class="line">    getListDataFromNet(page.num, page.size, function(curPageData)&#123;</span><br><span class="line">        //联网成功的回调,隐藏下拉刷新和上拉加载的状态;</span><br><span class="line">        //mescroll会根据传的参数,自动判断列表如果无任何数据,则提示空;列表无下一页数据,则提示无更多数据;</span><br><span class="line">        console.log(&quot;page.num=&quot;+page.num+&quot;, page.size=&quot;+page.size+&quot;, curPageData.length=&quot;+curPageData.length);</span><br><span class="line">        </span><br><span class="line">        //方法一(推荐): 后台接口有返回列表的总页数 totalPage</span><br><span class="line">        //mescroll.endByPage(curPageData.length, totalPage); //必传参数(当前页的数据个数, 总页数)</span><br><span class="line">        </span><br><span class="line">        //方法二(推荐): 后台接口有返回列表的总数据量 totalSize</span><br><span class="line">        //mescroll.endBySize(curPageData.length, totalSize); //必传参数(当前页的数据个数, 总数据量)</span><br><span class="line">        </span><br><span class="line">        //方法三(推荐): 您有其他方式知道是否有下一页 hasNext</span><br><span class="line">        //mescroll.endSuccess(curPageData.length, hasNext); //必传参数(当前页的数据个数, 是否有下一页true/false)</span><br><span class="line">        </span><br><span class="line">        //方法四 (不推荐),会存在一个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据当前页的数据个数判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.</span><br><span class="line">        mescroll.endSuccess(curPageData.length);</span><br><span class="line">        </span><br><span class="line">        //设置列表数据</span><br><span class="line">        setListData(curPageData, true);</span><br><span class="line">    &#125;, function()&#123;</span><br><span class="line">        //联网失败的回调,隐藏下拉刷新和上拉加载的状态;</span><br><span class="line">        mescroll.endErr();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码中并没有什么问题，但是实际运用中由于要判断是否存在下一页的情况，这里就会使用到<code>mescroll.endSuccess</code>这个方法(接口数据中并没有返回total或是pageTotal);</p><p>其实没有total或者pagetotal也不是什么大问题，完全可以通过pageSize来判断是否存在下一页数据，坑就坑在它的<code>加载中</code>这段标签也不是插件内部自动控制的，这个标签也需要用<code>mescroll.endSuccess</code>这个方法来进行判断，否则当前页加载完之后下次再拖到底部时就不会触发上拉加载方法。</p><h2 id="微信小程序的支付功能跳转"><a href="#微信小程序的支付功能跳转" class="headerlink" title="微信小程序的支付功能跳转"></a>微信小程序的支付功能跳转</h2><p>由于这次需求中将m站和小程序搞在一起，准备将m站嵌在小程序的<code>web-view</code>中，然而这里有个问题，那就是支付功能，小程序内部不允许调用微信接口的支付功能，只能使用调用小程序自己的支付接口，这意味着原本m站的支付功能将失效，而如果调用小程序的支付接口那就必须从内嵌的m站页面中将参数传给小程序，所以后来就想了一个办法，通过<code>webview</code>跳转时的<code>url</code>把支付所需参数传给小程序，从而调用小程序的支付功能。</p><p>具体实现是m站内部判断出当前环境是小程序还是h5页面，小程序则将支付所需参数通过调用小程序的跳转方法跳到一个空白的<code>web-veiw</code>上将url的参数带出，并在这个新的<code>web-view</code>上进行支付功能的实现，如果不是小程序就还是用原来的微信支付方式支付。小程序具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">   var that = this;</span><br><span class="line">   //页面加载调取微信支付（原则上应该对options的携带的参数进行校验）</span><br><span class="line">   that.requestPayment(options);</span><br><span class="line"> &#125;,</span><br><span class="line">//根据 obj 的参数请求wx 支付</span><br><span class="line"> requestPayment: function (obj) &#123;</span><br><span class="line">   //获取options的订单Id</span><br><span class="line">   var orderId = obj.orderId;</span><br><span class="line">   //调起微信支付</span><br><span class="line">   wx.requestPayment(&#123;</span><br><span class="line">     //相关支付参数</span><br><span class="line">     &apos;timeStamp&apos;: obj.timestamp,</span><br><span class="line">     &apos;nonceStr&apos;: obj.nonceStr,</span><br><span class="line">     &apos;package&apos;: &apos;prepay_id=&apos; + obj.prepay_id,</span><br><span class="line">     &apos;signType&apos;: obj.signType,</span><br><span class="line">     &apos;paySign&apos;: obj.paySign,</span><br><span class="line">     //小程序微信支付成功的回调通知</span><br><span class="line">     &apos;success&apos;: function (res) &#123;</span><br><span class="line">       //定义小程序页面集合</span><br><span class="line">       var pages = getCurrentPages();</span><br><span class="line">       //当前页面 (wxpay page)</span><br><span class="line">       var currPage = pages[pages.length - 1];  </span><br><span class="line">       //上一个页面 （index page） </span><br><span class="line">       var prevPage = pages[pages.length - 2];  </span><br><span class="line">       //通过page.setData方法使index的webview 重新加载url  有点类似于后台刷新页面</span><br><span class="line">       //此处有点类似小程序通过加载URL的方式回调通知后端 该订单支付成功。后端逻辑不做赘述。</span><br><span class="line">         prevPage.setData(&#123;</span><br><span class="line">           url: &quot;https://xxxxxxxxxx.com/wx_isPayment.jhtml?orderId=&quot; + orderId  + &apos;&amp;ispay=0&apos;,</span><br><span class="line">           </span><br><span class="line">         &#125;),</span><br><span class="line">         //小程序主动返回到上一个页面。即从wxpay page到index page。此时index page的webview已经重新加载了url 了</span><br><span class="line">         //微信小程序的page 也有栈的概念navigateBack 相当于页面出栈的操作</span><br><span class="line">         wx.navigateBack(); </span><br><span class="line">     &#125;,</span><br><span class="line">     //小程序支付失败的回调通知</span><br><span class="line">     &apos;fail&apos;: function (res) &#123;</span><br><span class="line">       console.log(&quot;支付失败&quot;),</span><br><span class="line">         console.log(res)</span><br><span class="line">         var pages=getCurrentPages();</span><br><span class="line">         var currPage = pages[pages.length - 1];   </span><br><span class="line">         var prevPage = pages[pages.length - 2];  </span><br><span class="line">         console.log(&quot;准备修改数据&quot;)</span><br><span class="line">         prevPage.setData(&#123;</span><br><span class="line">           url: &quot;https://xxxxxxxxxx/wx_isPayment.jhtml?orderId=&quot; + orderId + &apos;&amp;ispay=0&apos; ,</span><br><span class="line">         &#125;),</span><br><span class="line">           console.log(&quot;准备结束页面&quot;)</span><br><span class="line">       wx.navigateBack(); </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上就是这次项目中所获取的经验。</p><p>edit by AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日常Js学习汇总-2&quot;&gt;&lt;a href=&quot;#日常Js学习汇总-2&quot; class=&quot;headerlink&quot; title=&quot;日常Js学习汇总(2)&quot;&gt;&lt;/a&gt;日常Js学习汇总(2)&lt;/h1&gt;&lt;p&gt;最近搞项目改版，存在新老需求，这次就项目内遇到的一些问题和学习到的新知识
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React杂谈之Immutable</title>
    <link href="http://yoursite.com/2018/03/27/React%E6%9D%82%E8%B0%88%E4%B9%8BImmutable/"/>
    <id>http://yoursite.com/2018/03/27/React杂谈之Immutable/</id>
    <published>2018-03-27T06:23:07.000Z</published>
    <updated>2018-03-29T13:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React杂谈之Immutable-js"><a href="#React杂谈之Immutable-js" class="headerlink" title="React杂谈之Immutable.js"></a>React杂谈之Immutable.js</h1><h2 id="Immutable-js是什么，有何意义"><a href="#Immutable-js是什么，有何意义" class="headerlink" title="Immutable.js是什么，有何意义"></a>Immutable.js是什么，有何意义</h2><p><code>immutable</code>从英文翻译过来叫做<code>不可改变的</code>，所以<code>Immutable.js</code>就是用来生成不可变的数据的。</p><h3 id="Javascript的缺陷"><a href="#Javascript的缺陷" class="headerlink" title="Javascript的缺陷"></a>Javascript的缺陷</h3><p>众所周知在javascript中，对象一般是可变的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo=&#123;a: 1&#125;; </span><br><span class="line">let bar=foo; </span><br><span class="line">bar.a=2;</span><br><span class="line">console.log(foo.a)  // 2</span><br></pre></td></tr></table></figure></p><p>这里可以看出foo的a属性其实也跟着bar中的a属性发生了改变。</p><h3 id="Immutable的定义"><a href="#Immutable的定义" class="headerlink" title="Immutable的定义"></a>Immutable的定义</h3><p>这里就直接引用官方的原话了：</p><p>Immutable 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>那如果通过immutable来对对象进行操作会怎样呢，下面来看代码以便于更好地理解上面一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Immutable from &apos;immutable&apos;;</span><br><span class="line">let foo = Immutable.Object(&#123;a:1&#125;);</span><br><span class="line">let bar = foo.set(&apos;a&apos;,2);   // 定义一个bar变量，并且将一个新的Immutable返回给它</span><br><span class="line">console.log(foo.get(&apos;a&apos;));    // 获取foo对象(Immutable)的a属性，结果是1</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出虽然赋值给bar的时候对foo进行了修改操作，但是foo中的属性值并没有发生变化，这也就印证了上述所说‘Immutable 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象’的这句话。</p><h3 id="Immutable的意义"><a href="#Immutable的意义" class="headerlink" title="Immutable的意义"></a>Immutable的意义</h3><p>那么说了这么多，这个Immutable的意义究竟在哪里。这里主要分为以下几点：</p><ul><li><p>Immutable 降低了 Mutable 带来的复杂度</p><p>  可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function touchAndLog(touchFn) &#123;</span><br><span class="line">    let data = &#123; key: &apos;value&apos; &#125;;</span><br><span class="line">    touchFn(data);</span><br><span class="line">    console.log(data.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在上述代码中你不可能知道到底会打印出什么，因为我们无法确定touchFn对data到底做了哪些操作。那如果这个data是个Immutable类型的数据呢，毫无疑问打印出来是<code>value</code>。</p></li><li><p>节省内存</p><p>  Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</p></li><li><p>可以做到对于数据应用的时间旅行等功能</p><p>  因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</p></li><li><p>函数式编程</p><p>  Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</p></li></ul><h2 id="与React全家桶摩擦出的火花"><a href="#与React全家桶摩擦出的火花" class="headerlink" title="与React全家桶摩擦出的火花"></a>与React全家桶摩擦出的火花</h2><h3 id="在React中使用Immutable的好处"><a href="#在React中使用Immutable的好处" class="headerlink" title="在React中使用Immutable的好处"></a>在React中使用Immutable的好处</h3><p>其实下面这张图更方便理解：</p><p><img src="/images/immutable1.gif" alt="Immutable"></p><p>当数据发生改变的时候，只有关联节点会被修改，其他节点则会被复制一份，最终产生一个新的数据树；</p><p>由于react中我们只要执行了this.setState()方法，不管state的值是否发生变化都会重新执行一遍render方法进行重新渲染，所以在react中有一个名为<code>shouldComponentUpdate</code>的钩子函数，它会根据你返回的布尔值来进行判断是否重新进行渲染，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class CounterButton extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;count: 1&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    if (this.props.color !== nextProps.color) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.state.count !== nextState.count) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        color=&#123;this.props.color&#125;</span><br><span class="line">        onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</span><br><span class="line">        Count: &#123;this.state.count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是官方给的例子，然而可以看出来如果state结构异常复杂的话(<code>比如对象的嵌套</code>)这种比较是没有用的，这里存在着浅比较的问题这个钩子函数也会相应的变得复杂。(这里不明白的话可以去看<code>shouldComponentUpdate</code>的源码，对于嵌套对象的比较是用的<code>Object.is()</code>方法进行的比较)</p><p>对于这种情况，immutable就是一个非常好的解决方案，由于immutable的不可变性，我们可以非常轻松的在<code>shouldComponentUpdate</code>中进行<code>prevProps</code>和<code>nextProps</code>的比较。</p><p>Immutable中提供is()方法来进行Immutable对象间的比较,它比较的是两个对象的 hashCode 或 valueOf，由于<code>Immutable</code>内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p><h3 id="Immutable与Redux摩擦出的火花"><a href="#Immutable与Redux摩擦出的火花" class="headerlink" title="Immutable与Redux摩擦出的火花"></a>Immutable与Redux摩擦出的火花</h3><p>综上所述，为了避免浅比较存在的问题并且能够在redux数据流中进行react的渲染优化，我们可以将Immutable引入进来，引入Immutable就意味着要修改原本的数据结构类型，这就意味着我们要修改Action和Reducer以及组件中所有用到state的地方（工作量稍微有点庞大）,对于<code>Reducer</code>的修改    这里可以引入<code>redux-immutable</code>这个库。</p><p>修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; combineReducers &#125; from &apos;redux-immutablejs&apos;;</span><br><span class="line"></span><br><span class="line">import Immutable from &apos;immutable&apos;;</span><br><span class="line">import * as reducers from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">const reducer = combineReducers(reducers);</span><br><span class="line">const state = Immutable.fromJS(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">const store = reducer(state);</span><br><span class="line">export default createStore(reducer, store);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//reducers.js</span><br><span class="line"></span><br><span class="line">import &#123; createReducer &#125; from &apos;redux-immutablejs&apos;</span><br><span class="line">const initialState = Immutable.fromJS(&#123; isAuth: false &#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reducer domain that handles authentication &amp; authorization.</span><br><span class="line"> **/</span><br><span class="line">export default createReducer(initialState, &#123;</span><br><span class="line">  [LOGIN]: (state, action) =&gt; state.merge(&#123;</span><br><span class="line">    isAuth: true,</span><br><span class="line">    token: action.payload.token</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//container.js</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">    todos: state.get(&apos;todos&apos;).get(&apos;items&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">    actions: bindActionCreators(TodoActions, dispatch)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(App)</span><br></pre></td></tr></table></figure><p>对于container你也可以直接映射一个Immutable对象给state，通过get方法传递到元素中去，这里随便个人的喜好了。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>edit by AmamiRyoin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React杂谈之Immutable-js&quot;&gt;&lt;a href=&quot;#React杂谈之Immutable-js&quot; class=&quot;headerlink&quot; title=&quot;React杂谈之Immutable.js&quot;&gt;&lt;/a&gt;React杂谈之Immutable.js&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>HTML与Css小技巧(1)</title>
    <link href="http://yoursite.com/2018/03/24/HTML%E4%B8%8ECss%E5%B0%8F%E6%8A%80%E5%B7%A7(1)/"/>
    <id>http://yoursite.com/2018/03/24/HTML与Css小技巧(1)/</id>
    <published>2018-03-24T14:00:30.000Z</published>
    <updated>2018-03-24T14:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML与Css小技巧-1"><a href="#HTML与Css小技巧-1" class="headerlink" title="HTML与Css小技巧(1)"></a>HTML与Css小技巧(1)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>俗话说能用css解决的问题千万别用js，这里主要就给各位大佬介绍下不常用的或者说是新奇的css小技巧。</p><h3 id="css-混合模式"><a href="#css-混合模式" class="headerlink" title="css 混合模式"></a>css 混合模式</h3><p>熟悉PS的人应该都知道混合模式，实际上在<code>canvas</code>和<code>svg</code>中也有涉及，而在<code>css</code>中混合模式被称为<code>mix-blend-mode</code>，属性如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mix-blend-mode： normal;          //正常</span><br><span class="line">mix-blend-mode： multiply;        //正片叠底</span><br><span class="line">mix-blend-mode： screen;          //滤色</span><br><span class="line">mix-blend-mode： overlay;         //叠加</span><br><span class="line">mix-blend-mode： darken;          //变暗</span><br><span class="line">mix-blend-mode： lighten;         //变亮</span><br><span class="line">mix-blend-mode： color-dodge;     //颜色减淡</span><br><span class="line">mix-blend-mode： color-burn;      //颜色加深</span><br><span class="line">mix-blend-mode： hard-light;      //强光</span><br><span class="line">mix-blend-mode： soft-light;      //柔光</span><br><span class="line">mix-blend-mode： difference;      //差值</span><br><span class="line">mix-blend-mode： exclusion;       //排除</span><br><span class="line">mix-blend-mode： hue;             //色相</span><br><span class="line">mix-blend-mode： saturation;      //饱和度</span><br><span class="line">mix-blend-mode： color;           //颜色</span><br><span class="line">mix-blend-mode： luminosity;      //亮度</span><br><span class="line"></span><br><span class="line">mix-blend-mode： initial;         //初始</span><br><span class="line">mix-blend-mode： inherit;         //继承</span><br><span class="line">mix-blend-mode： unset;           //复原</span><br></pre></td></tr></table></figure><p>额，具体的什么效果我就不说了，程序员当然都是直接上代码啊！</p><p><div class="blend"><h4>请选择以下选项改变mix-blend-mode属性<br>    <select><br>        <option value="normal" selected>normal-正常</option><br>        <option value="multiply">multiply-正片叠底</option><br>        <option value="screen">screen-滤色</option><br>        <option value="overlay">overlay-叠加</option><br>        <option value="darken">darken-变暗</option><br>        <option value="lighten">lighten-变亮</option><br>        <option value="color-dodge">color-dodge-颜色减淡</option><br>        <option value="color-burn">color-burn-颜色加深</option><br>        <option value="hard-light">hard-light-强光</option><br>        <option value="soft-light">soft-light-柔光</option><br>        <option value="difference">difference-差值(</option><br>        <option value="exclusion">exclusion-排除</option><br>        <option value="hue">hue-色相</option><br>        <option value="saturation">saturation-饱和度</option><br>        <option value="color">color-颜色</option><br>        <option value="luminosity">luminosity-亮度</option><br>        <option value="initial">initial-初始</option><br>        <option value="inherit">inherit-继承</option><br>        <option value="unset">unset-复原</option><br>    </select><br></h4></div></p><p><style>.blend {width:100%;height:717px;background: url(/images/haruka_mana.jpg) no-repeat left top, url(/images/765pro.jpg) no-repeat left bottom;}</style></p><script type="text/javascript">if (window.addEventListener) {var eleBox = document.getElementsByClassName("blend")[0], eleSelect;if (eleBox && (eleSelect = eleBox.querySelector("select"))) {eleSelect.addEventListener("change", function() {eleBox.style.backgroundBlendMode = this.value;});}}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML与Css小技巧-1&quot;&gt;&lt;a href=&quot;#HTML与Css小技巧-1&quot; class=&quot;headerlink&quot; title=&quot;HTML与Css小技巧(1)&quot;&gt;&lt;/a&gt;HTML与Css小技巧(1)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
    
      <category term="HTML与CSS" scheme="http://yoursite.com/tags/HTML%E4%B8%8ECSS/"/>
    
  </entry>
  
  <entry>
    <title>日常Js学习汇总(1)</title>
    <link href="http://yoursite.com/2018/03/24/%E6%97%A5%E5%B8%B8Js%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB(1)/"/>
    <id>http://yoursite.com/2018/03/24/日常Js学习汇总(1)/</id>
    <published>2018-03-24T08:07:25.000Z</published>
    <updated>2018-03-24T12:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常Js学习汇总-1"><a href="#日常Js学习汇总-1" class="headerlink" title="日常Js学习汇总(1)"></a>日常Js学习汇总(1)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年11月份本来就打算开始写博客的结果拖到现在，也是服了自己的执行力了，不过总算也是开始写起来了。如果觉得写的不错，各位看官还请打个赏呗#滑稽<br>上个月刚跳槽换公司，面试时候出的笔试题当初做的一脸懵逼啊，倒不是说难，反而可以说是太基础，基础到平时大家都不会怎么去用（只是以我个人的观点来看，我承认自己基本功不是很扎实#流下了弱者的泪水），这里就凭着本人不算强的记忆力，把这些题目分享下。</p><h3 id="Js基础之Number对象"><a href="#Js基础之Number对象" class="headerlink" title="Js基础之Number对象"></a>Js基础之Number对象</h3><p>Number 对象是原始数值的包装对象。</p><h4 id="创建-Number-对象的语法："><a href="#创建-Number-对象的语法：" class="headerlink" title="创建 Number 对象的语法："></a>创建 Number 对象的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myNum=new Number(value);</span><br><span class="line">var myNum=Number(value);</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>参数 <code>value</code> 是要创建的 Number 对象的数值，或是要转换成数字的值。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，并且返回这个值（如果转换失败，则返回 NaN）。</p><h3 id="Number-对象属性"><a href="#Number-对象属性" class="headerlink" title="Number 对象属性"></a>Number 对象属性</h3><ul><li><p><code>constructor</code> ——–返回对此对象的 Number 函数的引用。</p></li><li><p><code>MAX_VALUE</code> ——–表示的最大的数。</p></li><li><p><code>Min_VALUE</code> ——–表示的最小的数。</p></li><li><p><code>NaN</code> ——–非数字值。(可以理解为Not a Number)</p></li><li><p><code>NEGATIVE_INFINITY</code> ——–负无穷大，溢出时返回该值。</p></li><li><p><code>POSITIVE_INFINITY</code> ——–正无穷大，溢出时返回该值。</p></li><li><p><code>prototype</code> ———原型。</p></li></ul><h3 id="Number-对象方法"><a href="#Number-对象方法" class="headerlink" title="Number 对象方法"></a>Number 对象方法</h3><ul><li><p><code>toString</code> ———把数字转换为字符串，使用指定的基数。</p></li><li><p><code>toLocaleString</code> ——–把数字转换为字符串，使用本地数字格式顺序。</p></li><li><p><code>toFixed</code> ——–把数字转换为字符串，结果的小数点后有指定位数的数字。</p></li><li><p><code>toExponential</code> ——–把对象的值转换为指数计数法。(这个不查手册还真不知道还有这种方法)</p></li><li><p><code>toPrecision</code> ——–把数字格式化为指定的长度。（这个也是查了手册才知道的）</p></li><li><p><code>valueOf</code> ——–返回一个 Number 对象的基本数字值。</p></li></ul><h3 id="对于Number对象的描述"><a href="#对于Number对象的描述" class="headerlink" title="对于Number对象的描述"></a>对于Number对象的描述</h3><p>在 <code>JavaScript</code> 中，数字是一种基本的数据类型。<code>JavaScript</code> 支持 <code>Number</code> 对象，该对象是原始数值的包装对象。在必要时，<code>JavaScript</code> 会自动地在原始数据和对象之间转换。构造函数 <code>Number()</code> 可以不与运算符 <code>new</code> 一起使用，而直接作为转化函数来使用。以这种方式调用 <code>Number()</code> 时，它会把自己的参数转化成一个数字，然后返回转换后的原始数值（或 <code>NaN</code>）。构造函数通常还用作 5 个有用的数字常量的占位符，这 5 个有用的数字常量分别是可表示的最大数、可表示的最小数、正无穷大、负无穷大和特殊的 <code>NaN</code> 值。 注意，这些值是构造函数 <code>Number()</code> 自身的属性，而不是单独的某个 <code>Number</code> 对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var big = Number.MAX_VALUE //正解</span><br><span class="line"></span><br><span class="line">var n= new Number(2);</span><br><span class="line">var big = n.MAX_VALUE; //错误用法，这里的变量n是new了Number对象，所以这里的n是Number的一个构造函数，并不是Number对象，所以它没有MAX_VALUE这个属性</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日常Js学习汇总-1&quot;&gt;&lt;a href=&quot;#日常Js学习汇总-1&quot; class=&quot;headerlink&quot; title=&quot;日常Js学习汇总(1)&quot;&gt;&lt;/a&gt;日常Js学习汇总(1)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
